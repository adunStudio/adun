# 동적 계획법

## 전통적 최적화 문제들

동적 계획법의 가장 일반적인 사용처는 최적화 문제의 해결이다. 최적화 문제란 여러 개의 가능한 답 중 가장 좋은 답(최적해)을 찾아내는 문제를 말한다.

사실 동적 계획법은 처으멩 최적화 문제의 해답을 빨리 찾기 위해 노력하는 과정에서 고안되었으며, 때문에 많은 많은 교과에서 동적 계획법을 논의할 때 최적화 과정을 가장 부각시켜 설명하고 있다.

최적화 문제를 동적 계획법으로 푸는 것 또한 완전 탐색에서 시작하지만, 최적화 문제에 특정 성질이 성립할 경우에는 단순히 메모이제이션을 적용하기보다 좀 더 효율적으로 동적 계획법을 구현할 수 있다.

------------

### 예제: 삼각형 위의 최대 경로

https://algospot.com/judge/problem/read/TRIANGLEPATH

#### 완전 탐색으로 시작하기

가장 먼저 완전 탐색을 통해 이 문제를 해결해보자.

경ㄹ로를 각 가로줄로 조각 낸 뒤, 각 조각에서는 아래로 내려갈지 오른쪽으로 내려갈지를 선택하면서 모든 경로를 만들기로 한다.

이때 재귀 호출 함수에는 현재 위치와 지금까지 만난 숫자들의 합을 전달하도록 한다. 그러면 다음과 같은 부분 문제를 얻을 수 있다.

*pathSum(y, x, sum)* = 현재 위치가 (y, x)이고, 지금 까지 만난 수의 합이 *sum*일 때, 이 경로를 맨 아래줄까지 연장해서 얻을 수 있는 최대 합을 반환한다.

이때 아래쪽으로 내려갔을 때와 오른쪽으로 내려갔을 때의 최대 합을 각각 path()를 이용하면 다음과 같다.

```cpp
int path1(int y, int x, int sum) {
    // 기저사례: 범위를 벗어난 경우
    if(y == size-1)
        return sum + triangle[y][x];

    sum += triangle[y][x];

    return max(path1(y+1, x, sum), path1(y+1, x+1, sum));
}
```

#### 무식하게 메모이제이션 적용하기

앞의 코드는 답을 구하기 위해 모든 경로를 다 만들어 봐야 한다는 문제가 있다. 이 문제에서 가능한 경로의 개수는 삼각형의 가로줄이 하나 늘어날 때마다 두 배씩 늘어나기 때문에 *n*개의 가로줄이 있을 때 가능한 경로의 수는 $$2^{n-1}$$이 된다.

메모이제이션을 적용해보자.

```cpp
// (y,x) 위치까지 내려오기 전에 만난 숫자들의 합이 sum 일 때
int path1(int y, int x, int sum) {
    // 기저 사례: 맨 아래 줄까지 도달했을 경우
    if(y == n-1)
        return sum + triangle[y][x];

    // 메모이제이션
    int& ret = cache[y][x][sum];
    if(ret != -1) return ret;
    sum += triangle[y][x];

    return ret = max(path1(y+1, x+1, sum), path1(y+1, x, sum));
}
```

이 코드는 멀쩡해 보이지만 알고 보면 중대한 문제가 있다.

1. 사용해야 하는 메모리가 너무 크다. 배열의 크기가 입력으로 주어지는 숫자의 범위에 좌우된다.
2. *path1()*이 특정 입력에 대해서는 완전 탐색처럼 동작한다는 것이다.

#### 입력 걸어내기

이 알고리즘을 더 빠르게 하는 힌트는 재귀 함수의 입력을 다음과 같이 두 부류로 나눠 보면 얻을 수 있다.

1. y와 x는 재귀 호출이 풀어야 할 부분 문제를 지정하다. 이 두 입력이 정해지면 앞으로 만들 수 있는 경로들이 정해진다. 따라서 이들은 앞으로 풀어야 할 조각들에 대한 정보를 주는 입력들이다.
2. 반면 *sum*은 지금까지 어떤 경로로 이 부분 문제에 도달했는지를 나타낸다. *sum*은 지금까지 풀었던 조각들에 대한 정보를 주는 입력이다.

![](http://www.adundocs.xyz/upload/15033232181213.jpeg)

다시 말하면 (y, x)는 그림 오른쪽에 아직 해결하지 못한 조각들을 정의하는 입력이고, *sum*은 왼쪽에 이미 결정한 조각들에 대한 정보이다. 그런데 과연 *sum*이 앞으로 남은 조각들을 푸는데 필요 할까?

(y, x)에서 맨 아래줄까지 내려가는 최대 경로는 *sum*이 얼마건 상관없이 똑같다.

재귀 함수에 *sum*을 아예 입력으로 받지 않도록 하면 이 알고리즘은 훨씬 빨라진다.

단 재귀 함수에서 *sum*을 입력 받지 않으면, 이전까지 어떤 숫자를 만났는지 알 수 없기 때문에 전체 경로의 최대 합을 반한할 수가 없다. 따라서 함수의 반환 값을 전체 경로의 최대치가 아니라 (y,x)에서 시작하는 부분 경로의 최대치로 바꿀 필요가 있다.

path2(y, x) = (y, x)에서 시작해서 맨 아래줄까지 내려가는 부분 경로의 최대 합을 반환한다.

전체 경로의 최대 합을 반환하는 것이 아니라 부분 경로의 최대합을 반환한다는 데 유의하자.

다시 말해 *path2()*는 앞으로 남은 조각들의 결과만을 반환한다.

![](http://www.adundocs.xyz/upload/1503317728323.jpeg)

```cpp
// 삼각형 위의 최대 경로 문제를 푸는 동적 계획법 알고리즘
int n, triangle[100][100];
int cache2[100][100];

// (y,x) 위치부터 맨 아래줄까지 내려가면서 얻을 수 있는 최대 경로의 합을 반환한다.
int path2(int y, int x) {
    // 기저 사례
    if(y == n-1)
        return triangle[y][x];

    // 메모이제이션
    int& ret = cache2[y][x];
    if(ret != -1)
        return ret;

    return ret = max(path2(y+1, x), path2(y + 1, x + 1)) + triangle[y][x];
}
```

위 알고리즘에서 부문 문제의 수는 O($$n^2$$)이고 각 부분 문제를 계산하는 데는 상수 시간밖에 안 걸리기 때문에 전체 시간 복잡도는 O($$n^2$$)이 된다.

#### 이론적 배경: 최적 부분 구조

위 코드의 동작 속도를 최적화할 수 있었던 이유는 *sum*이라는 정보가 (y,x)에서 맨 아래줄/가지 내려가는 문제를 해결하는 데 아무 상관이 없다는 사실을 파악한 덕분이다.

다시 말해, 지금까지 어떤 경로로 이 부분 문제에 도달했건 남은 부분 문제는 항상 최적으로 풀어도 상관 없다느 ㄴ뜻이다.

이것을  최적 부분 구조(optimal substructure)라는 유식한 이름을 붙여서 동적 계획법의 중요 요소로 꼽는다.

------------

### 예제: 최대 증가 부분 수열

https://algospot.com/judge/problem/read/LIS

#### 완전 탐색에서 시작하기

최대 증가 부분 수열을 찾는 문제를 숫자 하나씩으로 조각낸 뒤, 한 조각에서 숫자 하나씩을 선택하는 완전 탐색 알고리즘을 만들어 보자.

```cpp
// 최대 증가 부분 수열 문제를 해결하는 완전 탐색 알고리즘

int lis(const vetor<int>& A) {
    // 기저 사례: A가 텅 비어 있을때
    if(A.empty())
        return 0;

    int ret = 0;

    for(int i = 0; i < A.size(); ++i) {
        vector<int> B;

        for(int j = i + 1; j < A.size(); ++j)
            if(A[i] < A[j])
                B.push_back(A[j]);

        ret = max(ret, 1 + lis(B));
    }
}
```

#### 입력 손보기

위 코드의 완전 탐색 기능은 훌륭히 수행하지만, 입력이 정수가 아니라 정수의 배열이기 때문에 메모이제이션을 적용하기가 까다롭다.

A의 정의를 이용해 A를 좀 더 간단하게 표현하는 방법을 생각해보자. A는 하상 다음 두 가지 중 하나가 된다.

1. 원래 주어진 수열 S
2. 원래 주어진 수열 S[i]에 대해, S[i + 1 ...] 부분 수열에서 S[i]보다 큰 수들만 포함하는 부분 수열

2번 정의에서 이전에 선택한 수들이 정의에 포함되지 않은 데 주의하자. 이전에 선택된 수들은 어차피 마지막에 선택된 수보다 전에 있고 더 작기 때문에, 이들보다 뒤에 있고 커야 한다는 조건은 2번 조건만으로 모두 만족된다.

2번 정의에 포함되는 A는 S의 인덱스와 1:1 대응 된다는 점이다. A로 주어질 수 있는 입력은 전부 N+1가지밖에 없다는 이야기다.

lis(start) = S[start]에서 시작하는 부분 증가 수열 중 최대의 길이

재귀 호출할 때마다 S[start]보다 뒤에 있고 큰 수들 중 하나를 다음 숫자로 결정한 뒤, 여기서 시작하는 부분 증가 수열의 최대치를 구한다.

```cpp
// 최대 증가 부분 수열 문제를 해결하는 동적 계획법 알고리즘 (1)

int n;
int cache[100], S[100];

// S[start]에서 시작하는 증가 부분 수열 중 최대 길이를 반환한다.
int lis2(int start) {
    int& ret = cache[start];

    if(ret != -1)
        return ret;

	// 항상 S[start]는 있기 때문에 길이는 최하 1
	ret = 1;

    for(int next = start + 1; next < n; ++next)
        if(S[start] < S[next])
            ret = max(ret, lis2(next) + 1);

    return ret;
}

```

위 코드는 총 O(n)개의 부분 문제를 갖고, 하나를 해결할 때마다 O(n) 시간의 반복문을 순회하므로 전체 O($$n^2$$) 시간 복잡도를 갖는다.

#### 최적화 문제 동적 계획법 레시피

1. 모든 답을 만들어보고 그 중 최적해의 점수를 반환하는 완전 탐색 알고리즘을 설계한다.
2. 전체 답의 점수를 반환하는 것이 아니라, 앞으로 남은 선택들에 해당하는 점수만을 반환하도록 부분 문제 정의를 바꾼다.
3. 재귀 호출의 입력에 이전의 선택에 관련된 정보가 있다면 꼭 필요한 것만 남기고 줄인다. 가능한 한 중복되는 부분문제를 많이 만드는 것이 목표다. 입력의 종류가 줄어들면 줄어들 수록 더 많은 부분 문제가 중복되고, 따라서 메모이제이션을 최대한도로 활용할 수 있다.
4. 입력이 배열이 배열이거나 문자열인 경우 가능하다면 적절한 변환을 통해 메모이제이션할 수 있도록 한다.
5. 메모이제이션을 적용 한다.

------------
