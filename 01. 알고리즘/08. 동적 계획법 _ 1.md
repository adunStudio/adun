# 동적 계획법

동적 계획법은 프로그래밍 대회 문제에 가장 자주 출현하는 디자인 패러다임중 하나로, 이름만 가지고는 무엇을 의미하는지 영 알 수 없기 때문에 가장 많은 오해를 불러 일으키는 주제이기도 하다.

동적 계획법(dynamic programming)이라는 말은 최적화 문제를 연구하는 수학 이론에서 왓으며, 전산학에서 사용하는 동적(dynamic), 혹은 프로그래밍(programming)이란 단어와는 아무런 관련이 없다.

따라서 dynamic programming의 적절한 번역은 동적 프로그래밍이 아니라 동적 계획법이다.

## 중복되는 부분 문제

동적 계획법은 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다. 동적 계획법과 분할 정복의 차이가 발생하는 부분은 문제를 나누는 방식이다.

동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용함으로써 속도의 향상을 꾀할 수 있다.

그러기 위해서는 각 문제의 답을 메모리에 저장해 둘 필요가 있다. 이때 이미 계산한 값을 저장해 두는 메모리의 장소를 캐시(cache)라고 부르며, 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems)라고 부른다.

 동적 계획법 알고리즘의 가장 유명한 예 중 하나는 이항 계수(binomial co-efficient)의 계산이다. 이항 계수 $$\binom{n}{r}$$은 *n*개의 서로 다른 원소 중에서 *r*개의 원소를 순서 없이 골라내는 방법의 수를 나타내는 것으로, 이항 계수에는 다음과 같은 점화식이 성립한다.

$$\binom{n}{r}$$ = $$\binom{n-1}{r-1}$$ + $$\binom{n-1}{r}$$

이 점화식을 이용하면 *n , r*의 값이 주어질 때 $$\binom{n}{r}$$의 값을 반환하는 함수 *bino(n-r)*를 아래 코드와 같이 작성할 수 있다.

```cpp
// 재귀 호출을 이용한 이항 계수의 계산

int bino(int n, int r) {
    // 기저 사례 n=r (모든 원소를 다 고르는 경우 혹은 r=0 (고를 원소가 없는 경우)
    if(r == 0 || n == r) return 1;
    return bino(n-1, r-1) + bino(n-1, r);
}
```

주목할 점은 이항 계수의 특성상 같은 값을 두 번 이상 계산할 일이 빈번하다는 것이다.

*bino(4, 2)*를 계산하는 과정의 함수 호출을 그림으로 나타낸다면 *bino(2, 1)*이 두 번 호출된다는 것을 알 수 있다.

![](http://www.adundocs.xyz/upload/150295784612312.jpeg)

함수의 중복 호출 수는 n과 r이 커짐에 따라 기하급수적으로 증가한다.

마약 *bino(25, 12)*를 계산하기 위해서는 무려 1천만 번의 함수 호출이 필요하다.

입력인 *n*과 *r*이 정해져 있을 때 *bino(n, r)*의 반환 값이 일정하다는 사실을 이용하면 이 문제에서 중복 계산을 제거할 수 있다.

각 *n, r* 조합에 대해 답을 저장하는 캐시 배열을 만들어서 각 입력에 대한 반환 값을 저장하자. 함수는 매번 호출될 대마다 이 배열에 접근해 값이 저장되어 잇는지를 확인한 뒤, 저장되어 있따면 이것을 즉시 반환한다. 만약 계산되어 있지 않을 경우엔 직접 계산하여 배열에 써넣고 반환한다.

```cpp
// 메모이제이션을 이용한 이항 계수의 계산

// -1로 초기화해 둔다
int cache[30][30];

int bino2(int n, int r) {
    // 기저 사례
    if(r == 0 || n == r) return 1;
    // -1이 아니라면 한번 계산했던 값이니 곧장 반환
    if(cache[n][r] != -1)
        return cache[n][r];

    // 직접 계산한 뒤 배열에 저장
    return cache[n][r] = bino2(n-1, r-1) + bino2(n-1, r);
}
```

위 코드와 같이 함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법을 **메모제이션(memoization)**이라고 부른다.

메모이제이션을 사용하면 모든 부분 문제가 한 번씩만 계산된다고 보장할 수 있기 때문에 함수 호출 횟수가 엄청나게 감소하리라 예상할 수 있다.

이와 같이 두 번 이상 반복되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘 설계 기법을 동적 계획법이라고 한다.

## 메모이제이션을 적용할 수 있는 경우

혼란스러운 점 중 하나는, 수학의 함수와 프로그래밍에서의 함수가 비슷해보이지만 사실 다르나느 것이다. 수학의 함수에서는, 입력이 정해져 있을 때 출력도 언제나 정해져 있다.

예를 들어 sin(π)는 몇 번을 계산하건 항상 0이다. $$f(x) = \frac{x}{2}$$라고 하면 f(10)은 항상 5다.

그러나 프로그래밍은 이러한 속성이 성립하지 않는다. 프로그래밍에서의 함수는 함수의 입력 외에도 전역 변수, 입력 파일, 클래스의 멤버 변수 등 수많은 입력에 의해 작동하기 때문이다.

```cpp
int counter = 0;
int count() {
	return counter++;
}
```

위 함수는 입력을 전혀 받지 않으면서도 매번 다른 결과를 반환한다. 반면 입력이 같으면 출력도 항상 같은 함수도 작성할 수 있다. ex) *bino(), bino2()*

함수의 반환 값이 그 입력 값만으로 결정되는지의 여부를 *참조적 투명성(referential transparency)이라고 부른다.* 입력이 고정되어 있을 때 그 결과가 항상 같은 함수들을 참조적 투명함수라고 부른다.

메모이제이션은 참조적 투명 함수의 경우에만 적용할 수 있다.

입력이 같은데도 외부 요소에 따라 다른 값이 반환된다면 캐싱을 할 수가 없다.

## 메모이제이션 구현 패턴

동적 계획법에서 메모이제이션은 굉장히 자주 구현하게 된다. 그런 만큼 한 가지 패턴을 정해두고 항상 같은 형태로 구현하기로 하면 작성하기도,버그를 찾기도 쉽다.

다음과 같은 재귀 함수가 있다고 하자.

```cpp
// a와 b는 각각[0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b);
```

*someObscureFunction()*은 한 번 계산하는 데 굉장이 시간이 오래 걸리는 참조적 투명 함수라고 가정하겠다. 이 함수를 메모이제이션으로 바꿔 구현하는지를 보여주겠다. 다음과 같은 점을 유의하자.

- 항상 기저 사레를 제일 먼저 처리한다. 입력이 벗어난 경우 등을 기저 사례로 처리하면 매우 유용한데, 기저 사례를 먼저 확인하지 않고 *cache*[]에 접근하면 범위를 벗어나는 등의 오류가 있을 수 있다.
- 함수의 반환 값이 항상 0 이상이라는 점을 이용해 *cache*[]를 모두 -1로 초기화 한다.
- *ret*가 *cache*[*a*]\[*b*]에 대한 참조형이라는데 유의하자. 참조형 *ret*의 값을 바꾸면 *cache*[*a*]\[*b*]의 값도 변하기 때문에 답을 저장할 때도 매번 귀찮게 *cache*[*a*]\[*b*]라고 쓸 필요가 없어진다.
-  *memset()*을 이용해 *cache*[]를 초기화 한다. 다중 for문보다 쉽게 초기화할 수 있다. (memset() 주의! http://beautyrain.tistory.com/7)

```cpp
// 메모이제이션의 사용 예

// 전부 -1로 초기화해 둔다.
int cache[2500][2500];
// a와 비는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수.
int someObscureFunction(int a, int b) {
    // 기저 사례를 처음에 처리한다
    if(...) return ...;

    // (a, b)에 대한 답을 구한 적이 있으면 곧장 반환
    int& ret = cache[a][b];
    if(ret != -1) return ret;

    // 여기에서 답을 계산한다.
    ...
    return ret;
}

int main() {
    // memset()을 이요해 cache 배열을 초기화한다.
    memset(cache, -1, sizeof(cache));

}
```

------------

### 예제: 외발 뛰기

https://algospot.com/judge/problem/read/JUMPGAME

#### 재귀 호출에서 시작하기

동적 계획법 알고리즘을 만드는 첫 단계는 해당 문제를 재귀적으로 해결하는 완전 탐색 알고리즘을 만드는 것이다.

완전 탐색 알고리즘은 맨 왼쪽 윗 칸에서 시작하는 모든 경로를 하나씩 만들어 보면서 마지막 칸에 도달할 수 있는지를 검사한다.

이런 알고리즘은 재귀 호출로 자연스럽게 구현할 수 있다.

*jump(y, x) = (y, x)*에서부터 맨 마지막 칸까지 도달할 수 있는지 여부를 반환한다.

다음과 같이 재귀적으로 표현할 수 있다.

*jump(y, x) = jump(y + jumpSize, x) || jump(y + jumpSize, x)*

```cpp
bool jump(int y, int x) {

    // 기저 사례 1: 게임판 밖을 벗어난 경우
    if(y >= size || x >= size)
        return false;

    int jumpSize = board[y][x];

    // 기저 사례 2: 마지막에 도착한 경우
    if (jumpSize == 0)
        return true;

    return jump(y, x + jumpSize) || jump(y + jumpSize, x );

}
```

#### 메모제이션 적용하기

"원하는 답이 존재하는가?"라는 질문을 완전 탐색으로 구할 때 흔히 가장 문제가 되는 것은, 원하는 답은 없는데 전체 답의 개수는 무지막지하게 많은 경우다.

![](http://www.adundocs.xyz/upload/15029715343232.jpeg)

위 그림에서는 끝에 인접한 칸들에 2가 쓰여 있기 때문에 아무리 노력해도 끝에 도달할 수는 없지만 완전 탐색은 이 중 어던 경로는 마지막 칸에 도달할지도 모른다고 생각하고 수없이 많은 경로들을 일일이 탐색한다.

완전 탐색이 포기하기 전까지 만들어야 하는 경로의 개수는 n에 대해 지수적으로 늘어나므로, n = 100이면 제한시간을 초과해 버린다.

여기서 주목할 것은 완전 탐색이 만드는 경로의 수는 엄청나게 많지만 *jump()*에 주어지는 입력의 개수는 100* 100 = 10000개 뿐이라는 사실이다.

*jump()*는 참조적 투명 함수이기 때문에 메모이제이션을 적용해 중복된 연산을 없앨 수 있다.

```cpp
int cache[100][100];
int jump2(int y, int x) {
    // 기저 사례 1: 게임판 밖을 벗어난 경우
    if(y >= size || x >= size)
        return 0;

    if(y == size -1 && x == size -1)
        return 1;

    // 메모이제이션
    int& ret = cache[y][x];

    if(ret != -1)
        return ret;

    int jumpSize = board[y][x];

    return ret = jump(y, x + jumpSize) || jump(y + jumpSize, x );
}
```

*jump2()*가 불린값 배열을 캐시로 사용해서는 아직 계산되지 않은 상태인지 아닌지 알 수 있는 방법이 없기 때문에 정수를 반환한다.

*jump()*와 *jump2()*는 메모이제이션을 적용한 부분 말고는 완전히 똑같다. *jump2()*가 앞에서 다뤘던 메모이제이션 패턴을 충실히 따르고 있다는 점도 유의해서 보자.

#### 동적 계획법 레시피

대개 동적 계획법 알고리즘의 구현은 다음과 같은 두 단계로 이루어진다.

1. 주어진 문제를 완전 탐색을 이용해 해결한다.
2. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 적용한다.

------------

### 문제: 와일드카드

https://algospot.com/judge/problem/read/WILDCARD

#### \*가 문제로다.

이 문제가 어려운 점은 \*가 몇 글자에 대응되어야 하는지를 미리 알 수 없다는 점이다. 이럴때 할 수 있는 가장 쉬운 방법은 역시 완전 탐색이다.

주어진 패턴이 *m*개의 \*을 포함한다고 하자. 이 패턴을 \*가 나타날 때마다 쪼개면 이 패턴이 문자열에 대응되는지 확인하는 문제를 *m*+1조각으로 나눌 수 있다.

예를 들어 패턴 t\*l?\*o\*r?ng\*는 {t\*, l?\*, o\*, r?ng\*, s}의 다섯 조각으로 쪼개진다.

문자열 *thelordoftherings*가 주어질 때 완전 탐색 함수는 이 문자열 중 모두 몇 글자가 첫 번째 조각에 대응될지를 찾아내기 위해 모든 경우의 수를 다 시도해 본다.

만약 첫 번째 조각에 세 글자가 대응된다고 하면, 나머지 문자열 *lordoftherings*가 나머지 네 개의 패턴 조각들에 대응되는지의 여부를 재귀 호출로 파악할 수 있다.

```cpp
// 와일드카드 패턴 w가 문자열 s에 대응되는지 여부를 반환한다.
bool match(string& w, string& s) {

    // w[pos]와 s[pos]를 맟춰나간다.
    int pos = 0;

    while(pos < w.size() && pos < s.size() && (w[pos] == '?' || w[pos] == s[pos]))
        ++pos;

    // ...

    return true;
}
```

while문은 *w*와 *s*를 더이상 맟춰 나갈 수 없을 때 종료한다. 종료하는 경우의 수를 좀 더 자세히 따져보자.

1. *s*[*pos*]와 *w*[*pos*]가 대응되지 않는다.
2. *w* 끝에 도달했다.: 패턴에 \*이 하나도 없는 경우다. 이 경우에 패턴과 문자열의 길이가 정확히 같아야만 패턴과 문자열이 대응된다고 할 수 있다.
3. *s* 끝에 도달했다.: 패턴은 남았지만 문자열이 이미 끝난 경우다. 만약 패턴티 전부 \*로 구성되어 있다면 사실 두 문자열은 대응될 수 있다. 이 경우를 제외하고는 답은 항상 거짓이다.
4. *w*[*pos*]가 \*인 경우: \*가 몇 글자에 대응될지 모르기 때문에, 0 글자부터 남은 문자열의 길이까지를 순회하며 모든 가능성을 검사한다. 이때 *w*의 *pos*+1 이후를 패턴 *w'*으로 하고, *s*의 *pos* + *skip* 이후를 문자열 *s'*로 해서 *match(w', s')*로 재귀 호출했을 때 답이 하나라도 참이면 답은 참이 된다.

```cpp
//와일드카드 문제를 해결하는 완전 탐색 알고리즘


// 와일드카드 패턴 w가 문자열 s에 대응되는지 여부를 반환한다.
bool match(const string& w, const string& s) {

    // w[pos]와 s[pos]를 맟춰나간다.
    int pos = 0;

    while (pos < w.size() && pos < s.size() && (w[pos] == '?' || w[pos] == s[pos]))
        ++pos;

    // 더 이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.
    // 2. 패턴 끝에 도달해서 끝난 경우 문자열도 끝났어야 대응됨
    if (pos == w.size())
        return pos == s.size();

    // 4. *을 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.
    if (w[pos] == '*')
        for (int skip = 0; pos + skip <= s.size(); ++skip)
            if (match(w.substr(pos + 1), s.substr(pos + skip)))
                return true;

    // 이 외의 경우에는 모두 대응되지 않는다.
    return false;
}
```

#### 중복되는 부분 문제

위 알고리즘은 일부 예제 입력의 경우 너무 오랜 시간이 걸릴 수 있다는 문제가 있다.

완전 탐색은 각 \*에 대응되는 글자 수의 모든 조합을 검사하는데, 문자열이길고 \*이 많을 수록 이 경우의 수는 늘어난다.

만약 이 코드가 실행되는 과정에서 수행하는 계산의 대부분이 여러 번 중복으로 이루어진다면, 입력이 주어졌을 때 답을 저장하는 캐시를 이용하여 프로그램을 훨씬 빠르게 할 수 있을 것이다.

입력으로 주어질 수 있는 *w*와 *s*의 종류는 제한되어 있다. 재귀 호출할 때 항상 *w*와 *s*의 앞에서만 글자들을 떼내기 때문제 *w*와 *s*는 항상 입력에 주어진 패턴 *W*와 *S*의 접미사가 된다. 따라서 입력으로 주어질 수 있는 *w*와 *s*는 각각 최대 101개밖에 없다.

메모이제이션을 사용해 이 상황을 해결해보자.*w*는 항상 전체 패턴 *W*의 접미사이기 때문에 *w*의 길이가 결정되면 *w*또한 결정된다. 이 점을 이용하면 101 * 101 크기의 배열에 모든 부분 문제의 답을 저장할 수 있다.

```cpp
// 와일드카드 문제를 해결하는 동적계획법 알고리즘

// -1은 아직 답이 계산되지 않았음을 의미한다.
//  1은 해당 입력들이 서로 대응됨을 의미한다.
//  0은 해당 입력들이 서로 대응되지 않음을 의미한다.
int cache[101][101];

// 패턴과 문자열
string W, S;

// 와일드카드 패턴 W[w..]가 문자열 S[s..]에 대응되는지 여부를 반환한다.
bool matchMemoized(int w, int s) {
    // 메모이제이션
    int& ret = cache[w][s];
    if(ret != -1) return ret;

    // W[w]와 S[s]를 맟춰나간다.
    while(s < S.size() && w < W.size() && (W[w] == '?' || W[w] == S[s])) {
        ++w;
        ++s;
    }

    // 더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.
    // 2. 패턴 끝에 도달해서 끝난 경우 문자열도 끝났어야 대응됨
    if(w == W.size()) return ret = (s == S.size());

    // 4. *을 만나서 끝난 경우 *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.
    if(W[w] == '*')
        for(int skip = 0; skip + s <= S.size(); ++skip)
            if(matchMemoized(w+1, s + skip))
                return ret = 1;

    // 3. 이 외의 경우에는 모두 대응되지 않는다
    return ret = 0;
}
```

패턴과 문자열의 길이가 모두 n이라고 할 때, 부분 문제의 개수는 $$n^2$$이다.

*matchMemoized()*는 한 번 호출될 때마다 최대 n번의 재귀 호출을 하기 때문에 전체 시간 복잡도는 $$O(n^3)$$이 된다.

#### 다른 분해 방법

좀 더 똑똒한 분해 방식을 쓰면 이 문제를  $$O(n^2)$$ 시간에 풀 수 있다. 위 코드가  $$O(n^3)$$ 시간이 걸리는 것은 내부에서 첫 \*을 찾고, \*에 몇 글자가 대응되어야 할지 검사하는 반복문이 존재하기 때문이다.

만약 재귀 함수 자체에 반복문이 하나도 없도록 코드를 바꿀 수 있다면 부분 문제 개수와 같은 시간만을 사용해 문제를 풀 수 있다.

```cpp
// W[w]와 S[s]를 맟춰나간다.
while(s < S.size() && w < W.size() && (W[w] == '?' || W[w] == S[s])) {
    ++w;
    ++s;
}
```
위 코드에서 *w*와 *s*를 1씩 증가하고 계속하는 대신에 패턴과 문자열이 첫 한글자씩을 떼고 이들이 서로 대응되는지를 재귀 호출로 호출 할 수 있다.

```cpp
while(s < S.size() && w < W.size() && (W[w] == '?' || W[w] == S[s])) {
    return ret = matchMemoized(w+1, s+1);
}
```

다음으로는 \*에 몇 글자가 대응되어야 할지를 확인하는 반복문을 재귀 호출로 바꾼다.

1차원 for문을 재귀 호출로 바꾸는 것은 간단하다. 매 단계에서 \*에 아무 글자도 대응시키지 않을 것인지, 아니면 한글자를 더 대응시킬 것인가를 결정하면 된다.
```cpp
if(W[w] == '*') {
	if(matchMemoized(w+1, s) || (s < S.size() && matchMemoized(w, s + 1)))
		return ret = 1;
}
```

이렇게 하면 0 글자 대응되는 경우, 한 글자 대응되는 경우 등을 모두 재귀 호출을 통해 확인하고 그 과정을 메모이제이션으로 캐싱하게된다. 이와 같이 바꾸면 알고리즘의 시간 복잡도는 $$O(n^2)$$ 이 된다.
